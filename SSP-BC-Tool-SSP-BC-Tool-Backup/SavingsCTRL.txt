/* globals define */

define([
	'underscore',
	'text!resource/travelDelayCar.json',
	'text!resource/travelDelayTruck.json',
	'text!resource/fuelConsumption.json',
	'text!resource/fuelPrices.json',
	'text!resource/wageByState.json',
	'text!resource/wageByRegion.json'
	], function( _, travelDelayCar, travelDelayTruck, fuelConsumption, fuelPrices, wageByState, wageByRegion ) {

	var SavingsCTRL = function() {

		// travel delay parsed JSON object
		this.travelDelayCar = JSON.parse( travelDelayCar );
		this.travelDelayTruck = JSON.parse( travelDelayTruck );
		this.fuelConsumption = JSON.parse( fuelConsumption );
		this.fuelPrices = JSON.parse( fuelPrices );
		this.wageByState = JSON.parse( wageByState );
		this.wageByRegion = JSON.parse( wageByRegion );

		// returns an impact value based on given curvature
		this.getCurvatureImpact = function( curvature ) {
			if( curvature == 'Sharp Curves') {
				return 10;
			} else if( curvature == 'Mild Curves') {
				return 5;
			} else {
				return 0;
			}
		};

		// Returns a value based on a give terrain type
		this.getGeneralTerrainImpact = function( generalTerrain ) {
			if( generalTerrain === 'Mountainous' ) {
				return 10;
			} else if( generalTerrain == 'Rolling Hills') {
				return 5;
			} else {
				return 0;
			}
		};

		// object literal that retuns a value, which is a
		// percentage, based on a weather value
		this.weatherImpact = {
			'Clear': function() {
				return 0;
			},
			'Light Rain': function() {
				return .05;
			},
			'Heavy Rain': function() {
				return .10;
			},
			'Light Snow': function() {
				return .10;
			},
			'Low Visibility': function() {
				return .10;
			},
			'Fog': function() {
				return .15;
			},
			'Heavy Snow': function() {
				return .35;
			},
			'Icy Conditions': function() {
				return .45;
			},
		};

		// this builds a "weather object" that returns an object
		// with a name, percentage, and impact
		this.buildWeatherObject = function( segment ) {
			var _this = this;
			var prefixes = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh'];
			var weather = [];
			_.each( prefixes, function( prefix ){
				if( segment.get( prefix + 'WeatherState') === 'visible' ) {
					weather.push({
						name: segment.get( prefix + 'Weather'),
						percentage: segment.get( prefix + 'WeatherPrcnt'),
						impact: _this.weatherImpact[segment.get( prefix + 'Weather')]() * segment.get('mainLaneSpeedLimit')
					});
				}
			});
			return weather;
		};

		// object literal that returns a number that
		// represents a lane blockage
		this.getBlockageNum = {
			'shoulderBlockage': function() {
				return 0;
			},
			'oneLaneBlockage': function() {
				return 1;
			},
			'twoLaneBlockage': function() {
				return 2;
			},
			'threeLaneBlockage': function() {
				return 3;
			},
			'fourLaneBlockage': function() {
				return 4;
			},
			'fiveLaneBlockage': function() {
				return 5;
			},
			'sixLaneBlockage': function() {
				return 6;
			}
		};

		this.getIncidentsByWeather = function( objPeak ) {
			var incidentsByWeather = [];
			var hzCurvatureImpact, rampsImpact, weatherImpact;
			var _this = this;
			
			objPeak = Object.getPrototypeOf( objPeak );

			_.each( objPeak.blockages, function( blockage ) {
				_.each( objPeak.weather, function( weather ) {

					generalTerrainImpact = _this.getGeneralTerrainImpact( objPeak.generalTerrain );
					hzCurvatureImpact = _this.getCurvatureImpact( objPeak.horizontalCurvature );
					rampsImpact = _this.getRampsPerMileImpact( objPeak.rampsPerMile );
					weatherImpact = weather.impact;

					incidentsByWeather.push({
						peak: objPeak.name,
						weather: weather.name,
						blockage: blockage.name,
						blockageNum: _this.getBlockageNum[blockage.name](),
						blockageSavings: blockage.savings,
						incidents: ( weather.percentage / 100 ) * blockage.numManagedIncidents,
						hzCurvatureImpact: hzCurvatureImpact,
						numberOfLanes: objPeak.numberOfLanes,
						rampsImpact: rampsImpact,
						weatherImpact: weatherImpact,
						effectiveSpeed: _this.getSpeedAVG( _this.getEffectiveSpeed( objPeak.speedLimit, hzCurvatureImpact, rampsImpact, weatherImpact ) ),
						avgIncidentDuration: blockage.avgIncidentDuration,
						avgIncidentDurationWithSavings: blockage.avgIncidentDurationWithSavings,
						trafficVolume: _this.getRoundedTrafficVolume( objPeak.trafficVolume )
					});

				});
			});

			return incidentsByWeather;
		};

		// get the upper average based on a given array
		this.getUpper = function( array, value ) {
			if( value < array[0] ) {
				return array[0];
			} else {
				for( var i = 0, len = array.length; i < len; i++ ) {
					if( value == array[i] ) {
						return value;
					} else if( array[i] < value && array[i+1] > value ) {
						return array[i+1];
					}
				}
			}
		};

		// get the lower average based on a given array
		this.getLower = function( array, value ) {
			if( value < array[0] ) {
				return array[0];
			} else {
				for( var i = 0, len = array.length; i < len; i++ ) {
					if( value == array[i] ) {
						return value;
					} else if( array[i] < value && array[i+1] > value ) {
						return array[i];
					}
				}
			}
		};

		// returns the rounded result based on an array
		// of categories given
		this.roundArray = function( array, value) {
			for( var i = 0, len = array.length; i < len; i++ ) {
				if( value === array[i] ) {
					return value;
				} else if( array[i] < value && array[i+1] > value ) {
					var lower = array[i];
					var upper = array[i+1];
					var lowResult = value - lower;
					var uppResult = upper - value;
					if( uppResult <= lowResult ) {
						return upper;
					} else {
						return lower;
					} 
				}
			}

		};

		// get the speed average upper and lower categories
		// @param speed = this is the mainline speed given by the user
		this.getSpeedAVG = function( speed ) {
			var _this = this;
			var speeds = [60,70,80,90,100,120];
			speed = speed * 1.60934;
			return {
				value: speed,
				upper: _this.getUpper(speeds, speed),
				lower: _this.getLower(speeds, speed)
			}
		}

		// get the rounded traffic volume
		// @param trafficVolume  = get a traffic volume divided by the
		// number of lanes
		this.getRoundedTrafficVolume = function( trafficVolume ) {
			var _this = this;
			var volumes = [500,1000,1200,1400,1600,1800,2000,2200];
			var RTV = _this.roundArray( volumes, trafficVolume );
			return RTV;
		};

		// get the incident duration object with the SSP Savings
		// @param avgIncidentDuration = value taken from Incident Duration
		// for each Blockage for each Peak.
		this.incidentDurationAVG = function( avgIncidentDuration ) {
			var _this = this;
			var ID = [1,300,600,900,1200,1500,1800,2100,2400,2700,3000,3300,3600,3900,4200,4500,4800,5100,5400,5700,6000,6300,6600,6900,7200,9000,10800,12600,14400];
			return {
				value: avgIncidentDuration * 60,
				upper: _this.getUpper( ID, avgIncidentDuration * 60 ),
				lower: _this.getLower( ID, avgIncidentDuration * 60 )
			}
		};

		// get the incident duration object with the SSP Savings
		// @param avgIncidentDuration = value taken from Incident Duration
		// for each Blockage for each Peak.
		// @param minutesSavings = the value take from the Incident Duration
		// savings for each blockage.
		this.incidentDurationWithSavingsAVG = function( avgIncidentDuration, minutesSavings ) {
			var _this = this;
			var ID = [1,300,600,900,1200,1500,1800,2100,2400,2700,3000,3300,3600,3900,4200,4500,4800,5100,5400,5700,6000,6300,6600,6900,7200,9000,10800,12600,14400];

			avgIncidentDuration = avgIncidentDuration - minutesSavings;
			
			return {
				value: avgIncidentDuration * 60,
				upper: _this.getUpper( ID, avgIncidentDuration * 60 ),
				lower: _this.getLower( ID, avgIncidentDuration * 60 )
			}
		};

		this.getCarDelay = function ( options ) {

			options = options || {};

			_.each( travelDelayCar, function( TDC, index ) {					
				if( TDC['duration'] == options.duration && TDC['speed'] == options.speed && TDC['volume'] == options.volume ) {
					var index = options.lanes + '_' + options.blockage;
					return TDC[index];
				}
			});

			return 0;

		};

		this.getRampsPerMile = function( ramps, miles ) {
			return ramps / miles;
		};

		this.getRampsPerMileImpact = function( rampsPerMile ) {
			var RPM = Number( rampsPerMile );
			// 0 - 1.999
			if( RPM < 2 ) {
				return 0;
			} else
			// 2 - 3.999
			if( RPM >= 2 && RPM < 4 ) {
				return 5;
			} else
			// 4 - 5.999
			if( RPM >= 4 && RPM < 6 ) {
				return 10;
			} 
			// 6 and above
			else {
				return 15;
			}
		};

		// Returns the speed minus the maximum impact speed reduction
		// @param speed = the miles per hour user input
		// @param hzCurvatureImpact = the impact caused by horizontal curvature
		// @param RPMImpact = the impact caused by the number of ramps per mile
		// @param weatherImpact = the impact cause by the weather type
		this.getEffectiveSpeed = function( speed, hzCurvatureImpact, RPMImpact, weatherImpact ) {
			var impact = Math.max( hzCurvatureImpact, RPMImpact, weatherImpact );
			return speed - impact;
		};

		// Returns a total of the car and truck travel delay based on the
		// truck percentage e.g. if 10% are trucks then 90% are cars
		// @param meta = the incidents by weather object we created
		// @param truckPercentage = the percentage of trucks given by the user
		this.getTotalTravelDelay = function( meta, truckPercentage, withSavings ) {
			var totalTravelDelay = 0;

			if( withSavings ) {
				var travelDelayCar = meta.travelDelayCarWithSavings,
					travelDelayTruck = meta.travelDelayTruckWithSavings;
			} else {
				var travelDelayCar = meta.travelDelayCar,
						travelDelayTruck = meta.travelDelayTruck;
			}

			var totalTravelDelayCar = travelDelayCar * ((100 - truckPercentage) / 100);
			var totalTravelDelayTruck = travelDelayTruck * ( truckPercentage / 100);

			totalTravelDelay = totalTravelDelayCar + totalTravelDelayTruck;

			return totalTravelDelay;
		};

		// The functions that builds a Peak Object for a given operation time
		// @param segment = represents 1 segment with user inputs
		// @param strPeak = a String containing the name of a peak e.g. 'amPeak'
		this.buildPeak = function( segment, strPeak ) {
			var _this = this;
			var objPeak = {};
			// Check if a peak is active by checking its visibility
			if( segment.get( strPeak + 'Visibility' ) === 'visible' ) {
				// Create a "peak" object
				objPeak = {
					name: strPeak,
					trafficVolume: segment.get( strPeak + 'TrafficVolume'),
					truckPercentage: segment.get( strPeak + 'TruckPercentage'),
					rampsPerMile: segment.get('numberOfRamps') / segment.get('segmentLength'),
					generalTerrain: segment.get('generalTerrain'),
					horizontalCurvature: segment.get('horizontalCurvature'),
					speedLimit: segment.get('mainLaneSpeedLimit'),
					numberOfLanes: segment.get('numberOfTrafficLanesByDirection'),
					region: segment.get('region')
				};
				// Divide traffic volume by number of lanes by direction
				objPeak.trafficVolume = objPeak.trafficVolume / objPeak.numberOfLanes;
				// Create blockages array which contains each blockage
				var blockages = [];
				// Determine the number of blockages by the number of lanes
				// by direction and build blockage objects for each of them
				if( segment.get('averageDurationActive') == 'active') {
					var avgDurationSavings = segment.get('averageDurationSavings');
					// Switch case if the Average Duration is 'active'
					switch( segment.get('numberOfTrafficLanesByDirection') ) {
						case 5:
						case 6:
							blockages.push({
								name: 'fourLaneBlockage',							
								savings: Number( avgDurationSavings ),
								avgIncidentDuration: _this.incidentDurationAVG( segment.get( strPeak + 'FourLaneBlockageAVGID') ),
								avgIncidentDurationWithSavings: _this.incidentDurationAVG( segment.get( strPeak + 'FourLaneBlockageAVGID') - Number( avgDurationSavings ) ),
								numManagedIncidents: Number( segment.get( strPeak + 'FourLaneBlockageManIndt') )
							});
						case 4:
							blockages.push({
								name: 'threeLaneBlockage',							
								savings: Number( avgDurationSavings ),
								avgIncidentDuration:  _this.incidentDurationAVG( segment.get( strPeak + 'ThreeLaneBlockageAVGID') ),
								avgIncidentDurationWithSavings: _this.incidentDurationAVG( segment.get( strPeak + 'ThreeLaneBlockageAVGID') - Number( avgDurationSavings ) ),
								numManagedIncidents: Number( segment.get( strPeak + 'ThreeLaneBlockageManIndt') )
							});
						case 3:
							blockages.push({
								name: 'twoLaneBlockage',							
								savings: Number( avgDurationSavings ),
								avgIncidentDuration:  _this.incidentDurationAVG( segment.get( strPeak + 'TwoLaneBlockageAVGID') ),
								avgIncidentDurationWithSavings: _this.incidentDurationAVG( segment.get( strPeak + 'TwoLaneBlockageAVGID') - Number( avgDurationSavings ) ),
								numManagedIncidents: Number( segment.get( strPeak + 'TwoLaneBlockageManIndt') )
							});
						default:
							blockages.push({
								name: 'oneLaneBlockage',							
								savings: Number( avgDurationSavings ),
								avgIncidentDuration:  _this.incidentDurationAVG( segment.get( strPeak + 'OneLaneBlockageAVGID') ),
								avgIncidentDurationWithSavings: _this.incidentDurationAVG( segment.get( strPeak + 'OneLaneBlockageAVGID') - Number( avgDurationSavings ) ),
								numManagedIncidents: Number( segment.get( strPeak + 'OneLaneBlockageManIndt') )
							});
							blockages.push({
								name: 'shoulderBlockage',							
								savings: Number( avgDurationSavings ),
								avgIncidentDuration:  _this.incidentDurationAVG( segment.get( strPeak + 'ShoulderBlockageAVGID') ),
								avgIncidentDurationWithSavings: _this.incidentDurationAVG( segment.get( strPeak + 'ShoulderBlockageAVGID') - Number( avgDurationSavings ) ),
								numManagedIncidents: Number( segment.get( strPeak + 'ShoulderBlockageManIndt') )
							});
						break;
					}//- switch
				} else {
					// Switch case if the Average Duration Savings is not 'active'
					switch( segment.get('numberOfTrafficLanesByDirection') ) {
						case 5:
						case 6:
							blockages.push({
								name: 'fourLaneBlockage',							
								savings: Number( segment.get('fourLaneBlockageSavings') ),
								avgIncidentDuration: _this.incidentDurationAVG( segment.get( strPeak + 'FourLaneBlockageAVGID') ),
								avgIncidentDurationWithSavings: _this.incidentDurationAVG( segment.get( strPeak + 'FourLaneBlockageAVGID') - Number( segment.get('fourLaneBlockageSavings') ) ),
								numManagedIncidents: Number( segment.get( strPeak + 'FourLaneBlockageManIndt') )
							});
						case 4:
							blockages.push({
								name: 'threeLaneBlockage',							
								savings: Number( segment.get('threeLaneBlockageSavings') ),
								avgIncidentDuration:  _this.incidentDurationAVG( segment.get( strPeak + 'ThreeLaneBlockageAVGID') ),
								avgIncidentDurationWithSavings: _this.incidentDurationAVG( segment.get( strPeak + 'ThreeLaneBlockageAVGID') - Number( segment.get('threeLaneBlockageSavings') ) ),
								numManagedIncidents: Number( segment.get( strPeak + 'ThreeLaneBlockageManIndt') )
							});
						case 3:
							blockages.push({
								name: 'twoLaneBlockage',							
								savings: Number( segment.get('twoLaneBlockageSavings') ),
								avgIncidentDuration:  _this.incidentDurationAVG( segment.get( strPeak + 'TwoLaneBlockageAVGID') ),
								avgIncidentDurationWithSavings: _this.incidentDurationAVG( segment.get( strPeak + 'TwoLaneBlockageAVGID') - Number( segment.get('twoLaneBlockageSavings') ) ),
								numManagedIncidents: Number( segment.get( strPeak + 'TwoLaneBlockageManIndt') )
							});
						default:
							blockages.push({
								name: 'oneLaneBlockage',							
								savings: Number( segment.get('oneLaneBlockageSavings') ),
								avgIncidentDuration:  _this.incidentDurationAVG( segment.get( strPeak + 'OneLaneBlockageAVGID') ),
								avgIncidentDurationWithSavings: _this.incidentDurationAVG( segment.get( strPeak + 'OneLaneBlockageAVGID') - Number( segment.get('oneLaneBlockageSavings') ) ),
								numManagedIncidents: Number( segment.get( strPeak + 'OneLaneBlockageManIndt') )
							});
							blockages.push({
								name: 'shoulderBlockage',							
								savings: Number( segment.get('shoulderBlockageSavings') ),
								avgIncidentDuration:  _this.incidentDurationAVG( segment.get( strPeak + 'ShoulderBlockageAVGID') ),
								avgIncidentDurationWithSavings: _this.incidentDurationAVG( segment.get( strPeak + 'ShoulderBlockageAVGID') - Number( segment.get('shoulderBlockageSavings') ) ),
								numManagedIncidents: Number( segment.get( strPeak + 'ShoulderBlockageManIndt') )
							});
						break;
					}//- switch
				}
				// Add blockages to the peak object
				objPeak.blockages = blockages;
			}
			// return the peak object
			return objPeak;
		};

		// Begins the process of the calculations.
		// Builds Peak Objects for each active operation time based on user input.
		// @param segment = represents 1 segment with user inputs
		this.calculateDelaySavings = function( segment, projectState ) {
			var _this = this;
			// build peak object
			var peaks = ['amPeak', 'pmPeak', 'weekdayOffPeak', 'weekend'];
			var objPeaks = [];
			var tmpPeak = {};
			// Create an array of peaks that are active or visible
			_.each(peaks, function( peak ) {
				// Build peak object
				tmpPeak = Object.create( _this.buildPeak( segment, peak ) );
				// Check if peak object was built and add it to peaks array
				// otherwise skip it ensuring we only have active peak objects
				if( tmpPeak.name !== undefined ) {
					objPeaks.push( tmpPeak );
				}
			});
			// For each peak object get other properties needed for calculations
			var peakz = {};
      _.each(	objPeaks, function( peak ) {
      	peakz = Object.getPrototypeOf( peak );
      	// Get the rounded traffic volume for this peak
        peakz.roundedTrafficVolume = _this.getRoundedTrafficVolume( peakz.trafficVolume );
        // Build a separate weather object to make calculations
        // a lot easier to understand and debug
        peakz.weather = _this.buildWeatherObject( segment );
        // Get the number of incidents for each weather defined by the user
        peakz.incidentsByWeather = _this.getIncidentsByWeather( peak );
        // Get the Value of Secondary Incidents Prevented
        //peakz.secondarySavings = ;
        Object.defineProperty( peak, 'prototype', peakz);
      });
      // Get the travel delays for each peak's incident by weather
      var carPercentage = 0;
      var truckPercentage = 0;
      var fuelCost = _this.fuelPrices[projectState];
			_.each( objPeaks, function( peak ) {
				peak = Object.getPrototypeOf(peak);
				_.each( peak.incidentsByWeather, function( meta ) {
					// Compute the percentage of incidents for cars and trucks
					carPercentage = (100 - peak.truckPercentage) / 100;
					truckPercentage = peak.truckPercentage / 100;
					// Get travel delays without savings for 1 incident
					meta.travelDelayCar 	= _this.getTravelDelay( meta, 'car' );
					meta.travelDelayTruck = _this.getTravelDelay( meta, 'truck' );
					meta.totalTravelDelay = _this.getTotalTravelDelay( meta, peak.truckPercentage );
					// Get travel delays with the incident duration savings given by user
					meta.travelDelayCarWithSavings 	 = _this.getTravelDelay( meta, 'car', true );
					meta.travelDelayTruckWithSavings = _this.getTravelDelay( meta, 'truck', true );
					// Total travel delay for an incident
					meta.totalTravelDelayWithSavings = _this.getTotalTravelDelay( meta, peak.truckPercentage, true );
					// Calculate the Incident Delay for all incidents for this weather
					meta.incidentDelayCar = meta.travelDelayCar * meta.incidents * carPercentage;
					meta.incidentDelayCarSavings = meta.travelDelayCarWithSavings * meta.incidents * carPercentage;
					meta.incidentDelayTruck = meta.travelDelayTruck * meta.incidents * truckPercentage;
					meta.incidentDelayTruckSavings = meta.travelDelayTruckWithSavings * meta.incidents * truckPercentage;
					// Total Incident Delay
					meta.incidentDelayTotal = meta.incidentDelayCar + meta.incidentDelayTruck;
					meta.incidentDelayTotalSavings = meta.incidentDelayCarSavings + meta.incidentDelayTruckSavings;
					meta.incidentDelaySavings = meta.incidentDelayTotal - meta.incidentDelayTotalSavings;
					// Savings for all incidents for cars and trucks
					meta.incidentSavingsCar = meta.incidentDelayCar - meta.incidentDelayCarSavings;
					meta.incidentSavingsTruck = meta.incidentDelayTruck - meta.incidentDelayTruckSavings;
					/***
						Calculate fuel consumption
						***/
					meta.fuelConsumption = (_this.getTravelDelay( meta, 'fuel') / 2839.058835) * meta.incidents * carPercentage;
					meta.fuelConsumptionWithSavings = (_this.getTravelDelay( meta, 'fuel', true) / 2839.058835) * meta.incidents * carPercentage;
					meta.fuelSavings = (meta.fuelConsumption - meta.fuelConsumptionWithSavings) * fuelCost;
					meta.fuelSavingsGallons = meta.fuelConsumption - meta.fuelConsumptionWithSavings;
				});

			});

			_this.calculateTotalPeakSavings( objPeaks );

			return objPeaks;

		};

		this.calculateTotalPeakSavings = function( arrPeaks ) {
			var totalPeakIncidentDelay = 0;
			var totalPeakIncidentDelayCar = 0;
			var totalPeakIncidentDelayTruck = 0;
			var totalFuelSavings = 0;
			var totalFuelSavingsGallons = 0;

			_.each( arrPeaks, function( peak ) {
				peak = Object.getPrototypeOf( peak );
				_.each( peak.incidentsByWeather, function( meta ) {
					totalPeakIncidentDelay += meta.incidentDelaySavings;
					totalPeakIncidentDelayCar += meta.incidentSavingsCar;
					totalPeakIncidentDelayTruck += meta.incidentSavingsTruck;
					totalFuelSavings += meta.fuelSavings;
					totalFuelSavingsGallons += meta.fuelSavingsGallons;
				});

				peak.totalFuelSavings = totalFuelSavings;
				peak.totalFuelSavingsGallons = totalFuelSavingsGallons;
				peak.totalPeakSavings = {
					totalPeakIncidentDelay: totalPeakIncidentDelay,
					totalPeakIncidentDelayCar: totalPeakIncidentDelayCar,
					totalPeakIncidentDelayTruck: totalPeakIncidentDelayTruck
				};
			});

			return arrPeaks;

		};

		// This searches within a given table, which is a JSON object
		// and returns a value depending on the given parameters
		// @param delayTable = JSON object containing travel delays
		// @param speed = an integer value in kilometers
		// @param duration = an integer value in seconds
		// @param volume = an integer value of the volume of traffic
		// @param lane = number of lanes by direction
		// @param blockage = a number representing a blockage e.g. 0 means Shoulder Blockage
		this.getValueFromTable = function( delayTable, speed, duration, volume, lane, blockage ) {
			var delay;
			_.each( delayTable, function( item ) {
				if( item['speed'] == speed && item['duration'] == duration && item['volume'] == volume ) {
					delay = item;
				}
			});
			return delay;
		};

		// Returns a travel delay based on a given object and table
		// @param meta = is a peak object
		// @param table = is a JSON object containing travel delays
		this.getTravelDelay = function( meta, table, savings ) {
			var _this = this;

			// Checks if savings is given and then deduct it to the
			// incident duration
			if( savings === true ) {
				var incidentDuration = meta.avgIncidentDurationWithSavings;
			} else {
				var incidentDuration = meta.avgIncidentDuration;
			}

			var speed = meta.effectiveSpeed;
			var trafficVolume = meta.trafficVolume;
			var lane = meta.numberOfLanes;
			var blockage = meta.blockageNum;
			// for test check if undefined or give it default travel delay car
			if( table === 'fuel') {
				table =  _this.fuelConsumption;
			} else if( table === 'car') {
				table =  _this.travelDelayCar;
			} else if( table === 'truck') {
				table =  _this.travelDelayTruck;
			} else {
				return false;
			}

			var TD, TDSU, TDSL, SUIUTD, SLILTD, SUILTD, SLIUTD;

			// This triggers when there's an upper and lower speed
			// but an incident duration without upper and lower
			if( incidentDuration.upper === incidentDuration.lower && speed.upper != speed.lower ) {
				SUIUTD = _this.getValueFromTable( table, speed.upper, incidentDuration.upper, trafficVolume, lane, blockage);
				SLIUTD = _this.getValueFromTable( table, speed.lower, incidentDuration.upper, trafficVolume, lane, blockage);
				if( SUIUTD != undefined && SLIUTD != undefined ) {
					TD = SLIUTD[lane+'_'+blockage] + ( ((speed.value - speed.lower) / (speed.upper - speed.lower)) * ( SUIUTD[lane+'_'+blockage] - SLIUTD[lane+'_'+blockage] ) );
				} else {
					GlobalEvent.trigger('output:error');
				}
			}
			// This triggers when there's an upper and lower incident
			// duration but an even speed
			if( incidentDuration.upper != incidentDuration.lower && speed.upper === speed.lower ) {
				SUIUTD = _this.getValueFromTable( table, speed.upper, incidentDuration.upper, trafficVolume, lane, blockage);
				SUILTD = _this.getValueFromTable( table, speed.upper, incidentDuration.lower, trafficVolume, lane, blockage);
				if( SUIUTD != undefined && SUILTD != undefined ) {
					TD = SUILTD[lane+'_'+blockage] + ( ((incidentDuration.value - incidentDuration.lower) / (incidentDuration.upper - incidentDuration.lower)) * ( SUIUTD[lane+'_'+blockage] - SUILTD[lane+'_'+blockage] ) );
				} else {
					GlobalEvent.trigger('output:error');
				}
			}
			// This triggers when there's an upper and lower incident
			// duration but an even speed
			if( incidentDuration.upper === incidentDuration.lower && speed.upper === speed.lower ) {
				TD = _this.getValueFromTable( table, speed.value, incidentDuration.value, trafficVolume, lane, blockage);
				if( TD != undefined ) {
					TD = TD[lane+'_'+blockage];
				} else {
					GlobalEvent.trigger('output:error');
				}
			}

			// both speed and incident duration has an upper and lower
			// category for each
			if( incidentDuration.upper != incidentDuration.lower && speed.upper != speed.lower ) {
				SUIUTD = _this.getValueFromTable( table, speed.upper, incidentDuration.upper, trafficVolume, lane, blockage);
				SUILTD = _this.getValueFromTable( table, speed.upper, incidentDuration.lower, trafficVolume, lane, blockage);
				SLIUTD = _this.getValueFromTable( table, speed.lower, incidentDuration.upper, trafficVolume, lane, blockage);
				SLILTD = _this.getValueFromTable( table, speed.lower, incidentDuration.lower, trafficVolume, lane, blockage);

				if( SUIUTD != undefined && SLIUTD != undefined && SUILTD != undefined && SLILTD != undefined ) {
					TDSU = SUILTD[lane+'_'+blockage] + ( ((incidentDuration.value - incidentDuration.lower) / (incidentDuration.upper - incidentDuration.lower)) * ( SUIUTD[lane+'_'+blockage] - SUILTD[lane+'_'+blockage] ) );
					TDSL = SLILTD[lane+'_'+blockage] + ( ((incidentDuration.value - incidentDuration.lower) / (incidentDuration.upper - incidentDuration.lower)) * ( SLIUTD[lane+'_'+blockage] - SLILTD[lane+'_'+blockage] ) );
				} else {
					GlobalEvent.trigger('output:error');
				}

				if( TDSL != undefined && TDSU != undefined ) {
					TD = TDSL + ( ((speed.value - speed.lower) / (speed.upper - speed.lower)) * ( TDSU - TDSL ) );
				} else {
					GlobalEvent.trigger('output:error');
				}
			}


			return TD;

		};//-

		this.getNewTravelDelay = function( meta, truckPercentage, generalTerrain, table, savings ) {
			// Set savings to false by default
			savings = savings || false;
			
			if( savings === true ) {
				var incidentDuration = meta.avgIncidentDurationWithSavings;
			} else {
				var incidentDuration = meta.avgIncidentDuration;
			}

			var FFS = meta.effectiveSpeed * 1.60934,
					VOLUME = meta.trafficVolume,
					VOLUME2 = VOLUME * VOLUME,
					VOLUME3 = VOLUME2 * VOLUME,
					NUMBER_OF_LANES = meta.numberOfLanes,
					NUMBER_OF_BLOCKAGES = meta.blockageNum,
					NUMBER_OF_LANE_INDEX = (( NUMBER_OF_BLOCKAGES - 1 ) / NUMBER_OF_LANES ) * 100;
					DURATION_HOUR = incidentDuration.value / 60,
					COMP = VOLUME - ( VOLUME * truckPercentage );
					SQR_COMP = Math.sqrt( truckPercentage ),
					GRADIENT = _this.getGeneralTerrainImpact( generalTerrain );

			var TDc = -1.59 - (0.13 * NUMBER_OF_LANE_INDEX) + (0.55 * DURATION_HOUR) - (0.04 * (DURATION_HOUR * DURATION_HOUR)) + (0.01 * FFS ) + (0.02 * COMP) + (11.73 * VOLUME)- (5.04 * VOLUME2) + (0.71 * VOLUME3) + (0.15 * GRADIENT);

			return Math.pow(Math.E, TDc);

		};

		this.getDriverWage = function( state, region ) {
			var _this = this;
			var wage = 0;

			if( region === 'Other' || region === 'Select Region' ) {
				wage = _this.wageByState[state];
			} else {
				wage = _this.wageByRegion[region];
			}

			return Number( wage );

		};

		// Return SavingsCTRL
		return this;
	};

	return SavingsCTRL;

});